/* eslint-env jest */

import mysql from 'mysql'
import child_process from 'child_process'
import { Promise } from 'bluebird'
import { FreePBX } from './FreePBX'
import Conf from './Conf'
import Kvstore from './Kvstore'

jest.mock('mysql')
jest.mock('./Conf')
jest.mock('./Kvstore')
jest.mock('child_process')

describe('FreePBX is', () => {
  let freepbx
  beforeEach(() => {
    mysql.createPool = jest.fn()
    mysql.createPool.mockReturnValue('some-connection')
    freepbx = new FreePBX()
  })
  it('Check that constructor initialize correctly', () => {
    expect(freepbx.version).toEqual(null)
    expect(freepbx.connected).toEqual(false)
    expect(freepbx.config).toEqual(null)
    expect(freepbx.db).toEqual(null)
    expect(freepbx.kvstore).toEqual(null)
    expect(freepbx.astman).toEqual(null)
  })
  it('Check that connect function resolves current config if connected', () => {
    freepbx.connected = true
    freepbx.config = 'some-config'
    freepbx.db = 'some-db'
    return freepbx.connect().then(response => {
      expect(response).toEqual({
        config: 'some-config',
        db: 'some-db',
        kvstore: null,
        astman: null,
        version: null
      })
    })
  })
  it('Check connect function rejects if exec fails', () => {
    freepbx.exec = jest.fn()
    freepbx.exec.mockReturnValue(Promise.reject(new Error('exec failed')))
    return expect(freepbx.connect()).rejects.toEqual(new Error('exec failed'))
  })
  it('Check connect function resolves correctly if all success', () => {
    freepbx.exec = jest.fn()
    freepbx.exec.mockReturnValue(Promise.resolve({}))
    freepbx.databaseConnect = jest.fn()
    freepbx.databaseConnect.mockReturnValue(Promise.resolve({}))
    freepbx.loadConfig = jest.fn()
    freepbx.loadConfig.mockReturnValue(Promise.resolve({}))
    freepbx.getPBXVersion = jest.fn()
    freepbx.getPBXVersion.mockReturnValue(Promise.resolve({}))
    freepbx.loadKVStore = jest.fn()
    freepbx.loadKVStore.mockReturnValue(Promise.resolve({}))
    freepbx.AMIConnect = jest.fn()
    freepbx.AMIConnect.mockReturnValue(Promise.resolve({
      config: 'some-config',
      db: 'some-db',
      kvstore: 'some-kvstore',
      astman: 'some-astman'
    }))
    return freepbx.connect().then(response => {
      expect(response).toEqual({
        config: 'some-config',
        db: 'some-db',
        kvstore: 'some-kvstore',
        astman: 'some-astman',
        version: null
      })
      expect(freepbx.config).toEqual('some-config')
      expect(freepbx.db).toEqual('some-db')
      expect(freepbx.kvstore).toEqual('some-kvstore')
      expect(freepbx.astman).toEqual('some-astman')
      expect(freepbx.connected).toEqual(true)
    })
  })
  it('Check databaseConnect resolves database connection', () => {
    const config = {}
    return freepbx.databaseConnect({config}).then(response => {
      expect(response).toEqual({
        config,
        db: 'some-connection'
      })
    })
  })
  it('Check loadConfig rejects if load fails', () => {
    Conf.mockImplementation(() => {
      return {
        load: () => {
          return Promise.reject(new Error('load failed'))
        }
      }
    })
    const conf = {
      config: 'some-config',
      db: 'some-db'
    }
    return expect(freepbx.loadConfig(conf)).rejects.toEqual(new Error('load failed'))
  })
  it('Check loadConfig resolves correctly if all success', () => {
    const confClass = {
      load: () => {
        return Promise.resolve({})
      }
    }
    Conf.mockImplementation(() => {
      return confClass
    })
    const conf = {
      config: 'some-config',
      db: 'some-db'
    }
    return freepbx.loadConfig(conf).then(response => {
      expect(response).toEqual({
        config: confClass,
        db: 'some-db'
      })
    })
  })
  it('Check loadKVStore function resolves correctly', () => {
    const kvstore = {}
    Kvstore.mockImplementation(() => {
      return kvstore
    })
    const conf = {
      config: 'some-config',
      db: 'some-db'
    }
    return freepbx.loadKVStore(conf).then(response => {
      expect(response).toEqual({
        config: 'some-config',
        db:'some-db',
        kvstore
      })
    })
  })
  it('Check getPBXVersion function rejects if error', () => {
    const conf = {
      config: 'some-config',
      db: {
        query: (a,b) => b(new Error('query failed'), '', '')
      }
    }
    return expect(freepbx.getPBXVersion(conf)).rejects.toEqual(new Error('query failed'))
  })
  it('Check getPBXVersion function resolves if !error', () => {
    const conf = {
      config: 'some-config',
      db: {
        query: (a,b) => b(false,[{value: 'some-value'}], '')
      }
    }
    return freepbx.getPBXVersion(conf).then(response => {
      expect(response).toEqual(conf)
      expect(freepbx.version).toEqual('some-value')
    })
  })
  it('Check exec function rejects if err', () => {
    child_process.exec = (a,b) => b(new Error('err'), '', '')
    return expect(freepbx.exec('')).rejects.toEqual(new Error('err'))
  })
  it('Check exec function rejects if stderr', () => {
    child_process.exec = (a,b) => b(false, '', 'err')
    return expect(freepbx.exec('')).rejects.toEqual(new Error('err'))
  })
  it('Check exec function rejects if !JSON.parse', () => {
    child_process.exec = (a,b) => b(false, 'value', '')
    return expect(freepbx.exec('')).rejects.toBeDefined()
  })
  it('Check exec function resolves if all success', () => {
    child_process.exec = (a,b) => b(false, '{"conf": "value"}', false)
    return freepbx.exec('').then(response => {
      expect(response).toEqual({
        conf: 'value'
      })
    })
  })
})
