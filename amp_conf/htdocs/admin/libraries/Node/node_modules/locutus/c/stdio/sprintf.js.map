{"version":3,"sources":["../../../src/c/stdio/sprintf.js"],"names":["pad","str","minLength","padChar","leftJustify","diff","length","padStr","repeat","Math","max","module","exports","sprintf","format","args","placeholderRegex","index","replace","match","param","flags","width","prec","modifier","includes","split","reduce","pc","c","positiveSign","minWidth","precision","Error","arg","undefined","isNaN","String","number","trunc","abs","prefix","toString","op","Number","prototype","toExponential","toFixed","toPrecision","indexOf","toLowerCase","tr","toUpperCase","isSpecial","isFinite","substr","call","intVal","base","chr","charAt","fromCharCode"],"mappings":"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","file":"sprintf.js","sourcesContent":["function pad (str, minLength, padChar, leftJustify) {\n  const diff = minLength - str.length\n  const padStr = padChar.repeat(Math.max(0, diff))\n\n  return leftJustify ? str + padStr : padStr + str\n}\n\nmodule.exports = function sprintf (format, ...args) {\n  // original by: RafaÅ‚ Kukawski\n  //   example 1: sprintf('%+10.*d', 5, 1)\n  //   returns 1: '    +00001'\n  const placeholderRegex = /%(?:(\\d+)\\$)?([-+#0 ]*)(\\*|\\d+)?(?:\\.(\\*|\\d*))?([\\s\\S])/g\n\n  let index = 0\n\n  return format.replace(placeholderRegex, function (match, param, flags, width, prec, modifier) {\n    const leftJustify = flags.includes('-')\n\n    // flag '0' is ignored when flag '-' is present\n    const padChar = leftJustify ? ' '\n                      : flags.split('').reduce((pc, c) => [' ', '0'].includes(c) ? c : pc, ' ')\n\n    const positiveSign = flags.includes('+') ? '+' : flags.includes(' ') ? ' ' : ''\n\n    const minWidth = width === '*' ? args[index++] : +width || 0\n    let precision = prec === '*' ? args[index++] : +prec\n\n    if (param && !+param) {\n      throw Error(`Param index must be greater than 0`)\n    }\n\n    if (param && +param > args.length) {\n      throw Error(`Too few arguments`)\n    }\n\n    // compiling with default clang params, mixed positional and non-positional params\n    // give only a warning\n    const arg = param ? args[param - 1] : args[index++]\n\n    if (precision === undefined || isNaN(precision)) {\n      precision = 'eEfFgG'.includes(modifier) ? 6 : (modifier === 's' ? String(arg).length : undefined)\n    }\n\n    switch (modifier) {\n      case '%':\n        return '%'\n      case 'd':\n      case 'i': {\n        const number = Math.trunc(+arg || 0)\n        const abs = Math.abs(number)\n        const prefix = number < 0 ? '-' : positiveSign\n\n        const str = pad(abs.toString(), precision || 0, '0', false)\n\n        if (padChar === '0') {\n          return prefix + pad(str, minWidth - prefix.length, padChar, leftJustify)\n        }\n\n        return pad(prefix + str, minWidth, padChar, leftJustify)\n      }\n      case 'e':\n      case 'E':\n      case 'f':\n      case 'F':\n      case 'g':\n      case 'G': {\n        const number = +arg\n        const abs = Math.abs(number)\n        const prefix = number < 0 ? '-' : positiveSign\n\n        const op = [\n          Number.prototype.toExponential,\n          Number.prototype.toFixed,\n          Number.prototype.toPrecision\n        ]['efg'.indexOf(modifier.toLowerCase())]\n\n        const tr = [\n          String.prototype.toLowerCase,\n          String.prototype.toUpperCase\n        ]['eEfFgG'.indexOf(modifier) % 2]\n\n        const isSpecial = isNaN(abs) || !isFinite(abs)\n\n        let str = isSpecial ? abs.toString().substr(0, 3) : op.call(abs, precision)\n\n        if (padChar === '0' && !isSpecial) {\n          return prefix + pad(tr.call(str), minWidth - prefix.length, padChar, leftJustify)\n        }\n\n        return pad(tr.call(prefix + str), minWidth, isSpecial ? ' ' : padChar, leftJustify)\n      }\n      case 'b':\n      case 'o':\n      case 'u':\n      case 'x':\n      case 'X': {\n        const number = +arg || 0\n        const intVal = Math.trunc(number) + (number < 0 ? 0xFFFFFFFF + 1 : 0)\n        const base = [2, 8, 10, 16, 16]['bouxX'.indexOf(modifier)]\n        const prefix = intVal && flags.includes('#') ? ['', '0', '', '0x', '0X']['bouxXX'.indexOf(modifier)] : ''\n\n        if (padChar === '0' && prefix) {\n          return prefix + pad(pad(intVal.toString(base), precision, '0', false), minWidth - prefix.length, padChar, leftJustify)\n        }\n\n        return pad(prefix + pad(intVal.toString(base), precision, '0', false), minWidth, padChar, leftJustify)\n      }\n      case 'p':\n      case 'n': {\n        throw Error(`'${modifier}' modifier not supported`)\n      }\n      case 's': {\n        return pad(String(arg).substr(0, precision), minWidth, padChar, leftJustify)\n      }\n      case 'c': {\n        // extension, if arg is string, take first char\n        const chr = typeof arg === 'string' ? arg.charAt(0) : String.fromCharCode(+arg)\n        return pad(chr, minWidth, padChar, leftJustify)\n      }\n      case 'a':\n      case 'A':\n        throw Error(`'${modifier}' modifier not yet implemented`)\n      default:\n        // for unknown modifiers, return the modifier char\n        return modifier\n    }\n  })\n}\n"]}